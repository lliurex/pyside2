Description: Revert endl changes because incompatible with qt 5.14
Author: Gianfranco Costamagna <locutusofborg@debian.org>
Last-Update: 2020-06-06

Index: pyside-setup-opensource-src-5.15.1/sources/shiboken2/ApiExtractor/abstractmetabuilder.cpp
===================================================================
--- pyside-setup-opensource-src-5.15.1.orig/sources/shiboken2/ApiExtractor/abstractmetabuilder.cpp
+++ pyside-setup-opensource-src-5.15.1/sources/shiboken2/ApiExtractor/abstractmetabuilder.cpp
@@ -2927,7 +2927,7 @@ static void writeRejectLogFile(const QSt
 
 
     for (int reason = 0; reason < AbstractMetaBuilder::NoReason; ++reason) {
-        s << QString(72, QLatin1Char('*')) << Qt::endl;
+        s << QString(72, QLatin1Char('*')) << endl;
         switch (reason) {
         case AbstractMetaBuilder::NotInTypeSystem:
             s << "Not in type system";
@@ -2960,16 +2960,16 @@ static void writeRejectLogFile(const QSt
             break;
         }
 
-        s << Qt::endl;
+        s << endl;
 
         for (QMap<QString, AbstractMetaBuilder::RejectReason>::const_iterator it = rejects.constBegin();
              it != rejects.constEnd(); ++it) {
             if (it.value() != reason)
                 continue;
-            s << " - " << it.key() << Qt::endl;
+            s << " - " << it.key() << endl;
         }
 
-        s << QString(72, QLatin1Char('*')) << Qt::endl << Qt::endl;
+        s << QString(72, QLatin1Char('*')) << endl << endl;
     }
 
 }
Index: pyside-setup-opensource-src-5.15.1/sources/shiboken2/ApiExtractor/include.cpp
===================================================================
--- pyside-setup-opensource-src-5.15.1.orig/sources/shiboken2/ApiExtractor/include.cpp
+++ pyside-setup-opensource-src-5.15.1/sources/shiboken2/ApiExtractor/include.cpp
@@ -49,7 +49,7 @@ QtCompatHashFunctionType qHash(const Inc
 QTextStream& operator<<(QTextStream& out, const Include& include)
 {
     if (include.isValid())
-        out << include.toString() << Qt::endl;
+        out << include.toString() << endl;
     return out;
 }
 
Index: pyside-setup-opensource-src-5.15.1/sources/shiboken2/generator/main.cpp
===================================================================
--- pyside-setup-opensource-src-5.15.1.orig/sources/shiboken2/generator/main.cpp
+++ pyside-setup-opensource-src-5.15.1/sources/shiboken2/generator/main.cpp
@@ -78,11 +78,11 @@ static void printOptions(QTextStream &s,
         if (od.second.isEmpty()) {
             s << ", ";
         } else {
-            s << Qt::endl;
+            s << endl;
             const auto lines = od.second.splitRef(QLatin1Char('\n'));
             for (const auto &line : lines)
-                s << "        " << line << Qt::endl;
-            s << Qt::endl;
+                s << "        " << line << endl;
+            s << endl;
         }
     }
 }
@@ -346,7 +346,7 @@ void printUsage()
     for (const GeneratorPtr &generator : generators) {
         const OptionDescriptions options = generator->options();
         if (!options.isEmpty()) {
-            s << Qt::endl << generator->name() << " options:\n\n";
+            s << endl << generator->name() << " options:\n\n";
             printOptions(s, generator->options());
         }
     }
@@ -373,7 +373,7 @@ static void parseIncludePathOption(const
     const auto it = args.options.find(option);
     if (it != args.options.end()) {
         const QStringList includePathListList =
-            it.value().split(pathSplitter, Qt::SkipEmptyParts);
+            it.value().split(pathSplitter, QString::SkipEmptyParts);
         args.options.erase(it);
         for (const QString &s : includePathListList) {
             auto path = QFile::encodeName(QDir::cleanPath(s));
Index: pyside-setup-opensource-src-5.15.1/sources/shiboken2/generator/qtdoc/qtdocgenerator.cpp
===================================================================
--- pyside-setup-opensource-src-5.15.1.orig/sources/shiboken2/generator/qtdoc/qtdocgenerator.cpp
+++ pyside-setup-opensource-src-5.15.1/sources/shiboken2/generator/qtdoc/qtdocgenerator.cpp
@@ -172,7 +172,7 @@ static QChar lastChar(const QTextStream
 static QTextStream &ensureEndl(QTextStream &s)
 {
     if (lastChar(s) != QLatin1Char('\n'))
-        s << Qt::endl;
+        s << endl;
     return s;
 }
 
@@ -502,10 +502,10 @@ QString QtXmlToSphinx::transform(const Q
 
     if (!m_inlineImages.isEmpty()) {
         // Write out inline image definitions stored in handleInlineImageTag().
-        m_output << Qt::endl;
+        m_output << endl;
         for (const InlineImage &img : qAsConst(m_inlineImages))
-            m_output << ".. |" << img.tag << "| image:: " << img.href << Qt::endl;
-        m_output << Qt::endl;
+            m_output << ".. |" << img.tag << "| image:: " << img.href << endl;
+        m_output << endl;
         m_inlineImages.clear();
     }
 
@@ -608,11 +608,11 @@ void QtXmlToSphinx::handleHeadingTag(QXm
         else
             type = types[typeIdx];
     } else if (token == QXmlStreamReader::EndElement) {
-        m_output << Pad(type, headingSize) << Qt::endl << Qt::endl;
+        m_output << Pad(type, headingSize) << endl << endl;
     } else if (token == QXmlStreamReader::Characters) {
-        m_output << Qt::endl << Qt::endl;
+        m_output << endl << endl;
         headingSize = writeEscapedRstText(m_output, reader.text().trimmed());
-        m_output << Qt::endl;
+        m_output << endl;
     }
 }
 
@@ -628,7 +628,7 @@ void QtXmlToSphinx::handleParaTag(QXmlSt
         else if (result.startsWith(QLatin1String("**Note:**")))
             result.replace(0, 9, QLatin1String(".. note:: "));
 
-        m_output << INDENT << result << Qt::endl << Qt::endl;
+        m_output << INDENT << result << endl << endl;
     } else if (token == QXmlStreamReader::Characters) {
         const QStringRef text = reader.text();
         const QChar end = lastChar(m_output);
@@ -726,7 +726,7 @@ void QtXmlToSphinx::handleSeeAlsoTag(QXm
             handleLinkEnd(m_seeAlsoContext.data());
             m_seeAlsoContext.reset();
         }
-        m_output << Qt::endl << Qt::endl;
+        m_output << endl << endl;
         break;
     default:
         break;
@@ -747,7 +747,7 @@ void formatSnippet(QTextStream &str, Ind
     for (const QStringRef &line : lines) {
         if (!line.trimmed().isEmpty())
             str << indent << line;
-        str << Qt::endl;
+        str << endl;
     }
 }
 
@@ -811,7 +811,7 @@ void QtXmlToSphinx::handleSnippetTag(QXm
             m_output << INDENT << "<Code snippet \"" << location << ':' << identifier << "\" not found>\n";
         else
             formatSnippet(m_output, INDENT, code);
-        m_output << Qt::endl;
+        m_output << endl;
     }
 }
 void QtXmlToSphinx::handleDotsTag(QXmlStreamReader& reader)
@@ -930,16 +930,16 @@ void QtXmlToSphinx::handleListTag(QXmlSt
             switch (listType) {
             case BulletList:
             case OrderedList: {
-                m_output << Qt::endl;
+                m_output << endl;
                 const char *separator = listType == BulletList ? "* " : "#. ";
                 const char *indent    = listType == BulletList ? "  " : "   ";
                 for (const TableCell &cell : m_currentTable.constFirst()) {
                     const QVector<QStringRef> itemLines = cell.data.splitRef(QLatin1Char('\n'));
-                    m_output << INDENT << separator << itemLines.constFirst() << Qt::endl;
+                    m_output << INDENT << separator << itemLines.constFirst() << endl;
                     for (int i = 1, max = itemLines.count(); i < max; ++i)
-                        m_output << INDENT << indent << itemLines[i] << Qt::endl;
+                        m_output << INDENT << indent << itemLines[i] << endl;
                 }
-                m_output << Qt::endl;
+                m_output << endl;
             }
                 break;
             case EnumeratedList:
@@ -1144,7 +1144,7 @@ void QtXmlToSphinx::handleImageTag(QXmlS
         return;
     const QString href = reader.attributes().value(QLatin1String("href")).toString();
     if (copyImage(href))
-        m_output << INDENT << ".. image:: " <<  href << Qt::endl << Qt::endl;
+        m_output << INDENT << ".. image:: " <<  href << endl << endl;
 }
 
 void QtXmlToSphinx::handleInlineImageTag(QXmlStreamReader& reader)
@@ -1174,13 +1174,13 @@ void QtXmlToSphinx::handleRawTag(QXmlStr
     QXmlStreamReader::TokenType token = reader.tokenType();
     if (token == QXmlStreamReader::StartElement) {
         QString format = reader.attributes().value(QLatin1String("format")).toString();
-        m_output << INDENT << ".. raw:: " << format.toLower() << Qt::endl << Qt::endl;
+        m_output << INDENT << ".. raw:: " << format.toLower() << endl << endl;
     } else if (token == QXmlStreamReader::Characters) {
         const QVector<QStringRef> lst(reader.text().split(QLatin1Char('\n')));
         for (const QStringRef &row : lst)
-            m_output << INDENT << INDENT << row << Qt::endl;
+            m_output << INDENT << INDENT << row << endl;
     } else if (token == QXmlStreamReader::EndElement) {
-        m_output << Qt::endl << Qt::endl;
+        m_output << endl << endl;
     }
 }
 
@@ -1193,9 +1193,9 @@ void QtXmlToSphinx::handleCodeTag(QXmlSt
     } else if (token == QXmlStreamReader::Characters) {
         const QVector<QStringRef> lst(reader.text().split(QLatin1Char('\n')));
         for (const QStringRef &row : lst)
-            m_output << INDENT << INDENT << row << Qt::endl;
+            m_output << INDENT << INDENT << row << endl;
     } else if (token == QXmlStreamReader::EndElement) {
-        m_output << Qt::endl << Qt::endl;
+        m_output << endl << endl;
         INDENT.indent--;
     }
 }
@@ -1235,7 +1235,7 @@ void QtXmlToSphinx::handlePageTag(QXmlSt
        ? writeEscapedRstText(m_output, title)
        : writeEscapedRstText(m_output, fullTitle);
 
-    m_output << Qt::endl << Pad('*', size) << Qt::endl << Qt::endl;
+    m_output << endl << Pad('*', size) << endl << endl;
 }
 
 void QtXmlToSphinx::handleTargetTag(QXmlStreamReader &reader)
@@ -1299,7 +1299,7 @@ void QtXmlToSphinx::handleQuoteFileTag(Q
             m_output << INDENT << "<Code snippet \"" << location << "\" not found>\n";
         else
             formatCode(m_output, code, INDENT);
-        m_output << Qt::endl;
+        m_output << endl;
     }
 }
 
@@ -1435,7 +1435,7 @@ void QtXmlToSphinx::Table::format (QText
                 c = '-';
             s << Pad(c, colWidths.at(col)) << '+';
         }
-        s << Qt::endl;
+        s << endl;
 
 
         // Print the table cells
@@ -1452,7 +1452,7 @@ void QtXmlToSphinx::Table::format (QText
                 else
                     s << ' ';
                 if (rowLine < rowLines.count())
-                    s << qSetFieldWidth(colWidths[j]) << Qt::left << rowLines.at(rowLine) << qSetFieldWidth(0);
+                    s << qSetFieldWidth(colWidths[j]) << left << rowLines.at(rowLine) << qSetFieldWidth(0);
                 else
                     s << Pad(' ', colWidths.at(j));
             }
@@ -1461,7 +1461,7 @@ void QtXmlToSphinx::Table::format (QText
             s << "|\n";
         }
     }
-    s << INDENT << horizontalLine << Qt::endl << Qt::endl;
+    s << INDENT << horizontalLine << endl << endl;
 }
 
 static QString getFuncName(const AbstractMetaFunction* cppFunc) {
@@ -1563,11 +1563,11 @@ void QtDocGenerator::writeFormattedText(
             s << INDENT
                 << (typesystemIndentation > 0 && typesystemIndentation < line.size()
                     ? line.right(line.size() - typesystemIndentation) : line)
-                << Qt::endl;
+                << endl;
         }
     }
 
-    s << Qt::endl;
+    s << endl;
 }
 
 static void writeInheritedByList(QTextStream& s, const AbstractMetaClass* metaClass, const AbstractMetaClassList& allClasses)
@@ -1585,7 +1585,7 @@ static void writeInheritedByList(QTextSt
     QStringList classes;
     for (AbstractMetaClass *c : qAsConst(res))
         classes << QLatin1String(":ref:`") + c->name() + QLatin1Char('`');
-    s << classes.join(QLatin1String(", ")) << Qt::endl << Qt::endl;
+    s << classes.join(QLatin1String(", ")) << endl << endl;
 }
 
 // Extract the <brief> section from a WebXML (class) documentation and remove it
@@ -1626,16 +1626,16 @@ void QtDocGenerator::generateClass(QText
     s << ".. _" << className << ":" << "\n\n";
     s << ".. currentmodule:: " << metaClass->package() << "\n\n\n";
 
-    s << className << Qt::endl;
-    s << Pad('*', className.count()) << Qt::endl << Qt::endl;
+    s << className << endl;
+    s << Pad('*', className.count()) << endl << endl;
 
     auto documentation = metaClass->documentation();
     Documentation brief;
     if (extractBrief(&documentation, &brief))
         writeFormattedText(s, brief.value(), metaClass);
 
-    s << ".. inheritance-diagram:: " << metaClass->fullName() << Qt::endl
-      << "    :parts: 2" << Qt::endl << Qt::endl;
+    s << ".. inheritance-diagram:: " << metaClass->fullName() << endl
+      << "    :parts: 2" << endl << endl;
     // TODO: This would be a parameter in the future...
 
 
@@ -1744,17 +1744,17 @@ void QtDocGenerator::writeFunctionList(Q
 void QtDocGenerator::writeFunctionBlock(QTextStream& s, const QString& title, QStringList& functions)
 {
     if (!functions.isEmpty()) {
-        s << title << Qt::endl
-          << QString(title.size(), QLatin1Char('^')) << Qt::endl;
+        s << title << endl
+          << QString(title.size(), QLatin1Char('^')) << endl;
 
         std::sort(functions.begin(), functions.end());
 
         s << ".. container:: function_list\n\n";
         Indentation indentation(INDENT);
         for (const QString &func : qAsConst(functions))
-            s << INDENT << '*' << ' ' << func << Qt::endl;
+            s << INDENT << '*' << ' ' << func << endl;
 
-        s << Qt::endl << Qt::endl;
+        s << endl << endl;
     }
 }
 
@@ -1764,7 +1764,7 @@ void QtDocGenerator::writeEnums(QTextStr
 
     const AbstractMetaEnumList &enums = cppClass->enums();
     for (AbstractMetaEnum *en : enums) {
-        s << section_title << cppClass->fullName() << '.' << en->name() << Qt::endl << Qt::endl;
+        s << section_title << cppClass->fullName() << '.' << en->name() << endl << endl;
         writeFormattedText(s, en->documentation().value(), cppClass);
         const auto version = versionOf(en->typeEntry());
         if (!version.isNull())
@@ -1779,7 +1779,7 @@ void QtDocGenerator::writeFields(QTextSt
 
     const AbstractMetaFieldList &fields = cppClass->fields();
     for (AbstractMetaField *field : fields) {
-        s << section_title << cppClass->fullName() << "." << field->name() << Qt::endl << Qt::endl;
+        s << section_title << cppClass->fullName() << "." << field->name() << endl << endl;
         //TODO: request for member ‘documentation’ is ambiguous
         writeFormattedText(s, field->AbstractMetaAttributes::documentation().value(), cppClass);
     }
@@ -1827,14 +1827,14 @@ void QtDocGenerator::writeConstructors(Q
         }
     }
 
-    s << Qt::endl;
+    s << endl;
 
     for (QHash<QString, AbstractMetaArgument*>::const_iterator it = arg_map.cbegin(), end = arg_map.cend(); it != end; ++it) {
         Indentation indentation(INDENT, 2);
         writeParameterType(s, cppClass, it.value());
     }
 
-    s << Qt::endl;
+    s << endl;
 
     for (AbstractMetaFunction *func : qAsConst(lst))
         writeFormattedText(s, func->documentation().value(), cppClass);
@@ -1925,7 +1925,7 @@ void QtDocGenerator::writeDocSnips(QText
                 if (row.trimmed().size() == 0) {
                     if (currentRow == 0)
                         continue;
-                    s << Qt::endl;
+                    s << endl;
                 }
 
                 if (currentRow == 0) {
@@ -1939,7 +1939,7 @@ void QtDocGenerator::writeDocSnips(QText
                             break;
                     }
                 }
-                s << row.midRef(offset) << Qt::endl;
+                s << row.midRef(offset) << endl;
                 currentRow++;
             }
 
@@ -1979,7 +1979,7 @@ bool QtDocGenerator::writeInjectDocument
         }
     }
 
-    s << Qt::endl;
+    s << endl;
 
     // TODO: Deprecate the use of doc string on glue code.
     //       This is pre "add-function" and "inject-documentation" tags.
@@ -2069,13 +2069,13 @@ QString QtDocGenerator::translateToPytho
 void QtDocGenerator::writeParameterType(QTextStream& s, const AbstractMetaClass* cppClass, const AbstractMetaArgument* arg)
 {
     s << INDENT << ":param " << arg->name() << ": "
-      << translateToPythonType(arg->type(), cppClass) << Qt::endl;
+      << translateToPythonType(arg->type(), cppClass) << endl;
 }
 
 void QtDocGenerator::writeFunctionParametersType(QTextStream &s, const AbstractMetaClass *cppClass,
                                                  const AbstractMetaFunction *func)
 {
-    s << Qt::endl;
+    s << endl;
     const AbstractMetaArgumentList &funcArgs = func->arguments();
     for (AbstractMetaArgument *arg : funcArgs) {
 
@@ -2101,9 +2101,9 @@ void QtDocGenerator::writeFunctionParame
 
         if (retType.isEmpty())
             retType = translateToPythonType(func->type(), cppClass);
-        s << INDENT << ":rtype: " << retType << Qt::endl;
+        s << INDENT << ":rtype: " << retType << endl;
     }
-    s << Qt::endl;
+    s << endl;
 }
 
 void QtDocGenerator::writeFunction(QTextStream& s, const AbstractMetaClass* cppClass,
@@ -2162,7 +2162,7 @@ static void writeFancyToc(QTextStream& s
         std::sort(it.value().begin(), it.value().end());
 
         if (i)
-            ss << Qt::endl;
+            ss << endl;
 
         ss << "**" << it.key() << "**\n\n";
         i += 2; // a letter title is equivalent to two entries in space
@@ -2212,11 +2212,11 @@ void QtDocGenerator::writeModuleDocument
         FileOut output(outputDir + QLatin1String("/index.rst"));
         QTextStream& s = output.stream;
 
-        s << ".. module:: " << it.key() << Qt::endl << Qt::endl;
+        s << ".. module:: " << it.key() << endl << endl;
 
         const QString &title = it.key();
-        s << title << Qt::endl;
-        s << Pad('*', title.length()) << Qt::endl << Qt::endl;
+        s << title << endl;
+        s << Pad('*', title.length()) << endl << endl;
 
         /* Avoid showing "Detailed Description for *every* class in toc tree */
         Indentation indentation(INDENT);
@@ -2258,8 +2258,8 @@ void QtDocGenerator::writeModuleDocument
             Indentation deeperIndentation(INDENT);
             s << INDENT << ":maxdepth: 1\n\n";
             for (const QString &className : qAsConst(it.value()))
-                s << INDENT << className << Qt::endl;
-            s << Qt::endl << Qt::endl;
+                s << INDENT << className << endl;
+            s << endl << endl;
         }
 
         s << "Detailed Description\n--------------------\n\n";
Index: pyside-setup-opensource-src-5.15.1/sources/shiboken2/generator/shiboken2/cppgenerator.cpp
===================================================================
--- pyside-setup-opensource-src-5.15.1.orig/sources/shiboken2/generator/shiboken2/cppgenerator.cpp
+++ pyside-setup-opensource-src-5.15.1/sources/shiboken2/generator/shiboken2/cppgenerator.cpp
@@ -297,7 +297,7 @@ void CppGenerator::generateClass(QTextSt
     const AbstractMetaClass *metaClass = classContext.metaClass();
 
     // write license comment
-    s << licenseComment() << Qt::endl;
+    s << licenseComment() << endl;
 
     if (!avoidProtectedHack() && !metaClass->isNamespace() && !metaClass->hasPrivateDestructor()) {
         s << "//workaround to access protected functions\n";
@@ -341,7 +341,7 @@ void CppGenerator::generateClass(QTextSt
     headerfile.replace(QLatin1String(".cpp"), QLatin1String(".h"));
     s << "\n// main header\n" << "#include \"" << headerfile << "\"\n";
 
-    s << Qt::endl << "// inner classes\n";
+    s << endl << "// inner classes\n";
     const AbstractMetaClassList &innerClasses = metaClass->innerClasses();
     for (AbstractMetaClass *innerClass : innerClasses) {
         GeneratorContext innerClassContext = contextForClass(innerClass);
@@ -363,8 +363,8 @@ void CppGenerator::generateClass(QTextSt
         includes.append(cppEnum->typeEntry()->extraIncludes());
     std::sort(includes.begin(), includes.end());
     for (const Include &inc : qAsConst(includes))
-        s << inc.toString() << Qt::endl;
-    s << Qt::endl;
+        s << inc.toString() << endl;
+    s << endl;
 
     s << "\n#include <cctype>\n#include <cstring>\n";
 
@@ -383,7 +383,7 @@ void CppGenerator::generateClass(QTextSt
         }
     }
 
-    s << Qt::endl << Qt::endl << typeNameFunc << Qt::endl;
+    s << endl << endl << typeNameFunc << endl;
 
     // Create string literal for smart pointer getter method.
     if (classContext.forSmartPointer()) {
@@ -399,13 +399,13 @@ void CppGenerator::generateClass(QTextSt
         writeClassCodeSnips(s, metaClass->typeEntry()->codeSnips(),
                             TypeSystem::CodeSnipPositionBeginning, TypeSystem::NativeCode,
                             classContext);
-        s << Qt::endl;
+        s << endl;
     }
 
     // python conversion rules
     if (metaClass->typeEntry()->hasTargetConversionRule()) {
         s << "// Python Conversion\n";
-        s << metaClass->typeEntry()->conversionRule() << Qt::endl;
+        s << metaClass->typeEntry()->conversionRule() << endl;
     }
 
     if (classContext.useWrapper()) {
@@ -557,7 +557,7 @@ void CppGenerator::generateClass(QTextSt
 
     // Write methods definition
     s << "static PyMethodDef " << className << "_methods[] = {\n";
-    s << methodsDefinitions << Qt::endl;
+    s << methodsDefinitions << endl;
     if (metaClass->typeEntry()->isValue() || metaClass->typeEntry()->isSmartPointer()) {
         s << INDENT << "{\"__copy__\", reinterpret_cast<PyCFunction>(" << className << "___copy__)"
             << ", METH_NOARGS},\n";
@@ -584,9 +584,9 @@ void CppGenerator::generateClass(QTextSt
         writeCppSelfDefinition(s, classContext);
         if (f->allowThread()) {
             s << INDENT << "int result;\n";
-            s << INDENT << BEGIN_ALLOW_THREADS << Qt::endl;
+            s << INDENT << BEGIN_ALLOW_THREADS << endl;
             s << INDENT << "result = !" << CPP_SELF_VAR << "->isNull();\n";
-            s << INDENT << END_ALLOW_THREADS << Qt::endl;
+            s << INDENT << END_ALLOW_THREADS << endl;
             s << INDENT << "return result;\n";
         } else {
             s << INDENT << "return !" << CPP_SELF_VAR << "->isNull();\n";
@@ -639,10 +639,10 @@ void CppGenerator::generateClass(QTextSt
             writeGetterFunction(s, metaField, classContext);
             if (canGenerateFieldSetter(metaField))
                 writeSetterFunction(s, metaField, classContext);
-            s << Qt::endl;
+            s << endl;
         }
 
-        s << "// Getters and Setters for " << metaClass->name() << Qt::endl;
+        s << "// Getters and Setters for " << metaClass->name() << endl;
         s << "static PyGetSetDef " << cpythonGettersSettersDefinitionName(metaClass) << "[] = {\n";
         for (const AbstractMetaField *metaField : fields) {
             if (metaField->isStatic())
@@ -670,7 +670,7 @@ void CppGenerator::generateClass(QTextSt
     writeTpClearFunction(s, metaClass);
 
     writeClassDefinition(s, metaClass, classContext);
-    s << Qt::endl;
+    s << endl;
 
     if (metaClass->isPolymorphic() && metaClass->baseClass())
         writeTypeDiscoveryFunction(s, metaClass);
@@ -684,10 +684,10 @@ void CppGenerator::generateClass(QTextSt
         if (hasFlags) {
             writeFlagsMethods(s, cppEnum);
             writeFlagsNumberMethodsDefinition(s, cppEnum);
-            s << Qt::endl;
+            s << endl;
         }
     }
-    s << Qt::endl;
+    s << endl;
 
     writeConverterFunctions(s, metaClass, classContext);
     writeClassRegister(s, metaClass, classContext, signatureStream);
@@ -697,7 +697,7 @@ void CppGenerator::generateClass(QTextSt
         writeClassCodeSnips(s, metaClass->typeEntry()->codeSnips(),
                             TypeSystem::CodeSnipPositionEnd, TypeSystem::NativeCode,
                             classContext);
-        s << Qt::endl;
+        s << endl;
     }
 }
 
@@ -868,7 +868,7 @@ QString CppGenerator::virtualMethodRetur
         errorMsg += func->signature();
         errorMsg = msgCouldNotFindMinimalConstructor(errorMsg, func->type()->cppSignature());
         qCWarning(lcShiboken).noquote().nospace() << errorMsg;
-        s << Qt::endl << INDENT << "#error " << errorMsg << Qt::endl;
+        s << endl << INDENT << "#error " << errorMsg << endl;
     }
     if (returnType->referenceType() == LValueReference) {
         s << INDENT << "static " << returnType->typeEntry()->qualifiedCppName()
@@ -1014,7 +1014,7 @@ void CppGenerator::writeVirtualMethodNat
         }
 
         s << "Py_BuildValue(\"(" << getFormatUnitString(func, false) << ")\",\n";
-        s << argConversions.join(QLatin1String(",\n")) << Qt::endl;
+        s << argConversions.join(QLatin1String(",\n")) << endl;
         s << INDENT << "));\n";
     }
 
@@ -1031,7 +1031,7 @@ void CppGenerator::writeVirtualMethodNat
             }
         }
     }
-    s << Qt::endl;
+    s << endl;
 
     if (!snips.isEmpty()) {
         if (injectedCodeUsesPySelf(func))
@@ -1136,7 +1136,7 @@ void CppGenerator::writeVirtualMethodNat
     }
 
     if (func->hasInjectedCode()) {
-        s << Qt::endl;
+        s << endl;
         const AbstractMetaArgument *lastArg = func->arguments().isEmpty() ? nullptr : func->arguments().constLast();
         writeCodeSnips(s, snips, TypeSystem::CodeSnipPositionEnd, TypeSystem::NativeCode, func, lastArg);
     }
@@ -1265,7 +1265,7 @@ void CppGenerator::writeEnumConverterFun
     }
     c << ";\n";
     writeCppToPythonFunction(s, code, typeName, typeName);
-    s << Qt::endl;
+    s << endl;
 
     if (enumType->isFlags())
         return;
@@ -1346,7 +1346,7 @@ void CppGenerator::writeConverterFunctio
     const QString pyTypeCheck = QLatin1String("PyObject_TypeCheck(pyIn, reinterpret_cast<PyTypeObject *>(")
         + cpythonType + QLatin1String("))");
     writeIsPythonConvertibleToCppFunction(s, sourceTypeName, targetTypeName, pyTypeCheck, QString(), true);
-    s << Qt::endl;
+    s << endl;
 
     // C++ pointer to a Python wrapper, keeping identity.
     s << "// C++ to Python pointer conversion - tries to find the Python wrapper for the C++ object (keeps object identity).\n";
@@ -1383,12 +1383,12 @@ void CppGenerator::writeConverterFunctio
 
     // The conversions for an Object Type end here.
     if (!metaClass->typeEntry()->isValue() && !metaClass->typeEntry()->isSmartPointer()) {
-        s << Qt::endl;
+        s << endl;
         return;
     }
 
     // Always copies C++ value (not pointer, and not reference) to a new Python wrapper.
-    s << Qt::endl << "// C++ to Python copy conversion.\n";
+    s << endl << "// C++ to Python copy conversion.\n";
     if (!classContext.forSmartPointer())
         targetTypeName = metaClass->name();
     else
@@ -1410,7 +1410,7 @@ void CppGenerator::writeConverterFunctio
         << ", new ::" << computedWrapperName << "(*reinterpret_cast<const "
         << typeName << " *>(cppIn)), true, true);";
     writeCppToPythonFunction(s, code, sourceTypeName, targetTypeName);
-    s << Qt::endl;
+    s << endl;
 
     // Python to C++ copy conversion.
     s << "// Python to C++ copy conversion.\n";
@@ -1435,7 +1435,7 @@ void CppGenerator::writeConverterFunctio
 
     // "Is convertible" function for the Python object to C++ value copy conversion.
     writeIsPythonConvertibleToCppFunction(s, sourceTypeName, targetTypeName, pyTypeCheck);
-    s << Qt::endl;
+    s << endl;
 
     // User provided implicit conversions.
     CustomConversion *customConversion = metaClass->typeEntry()->customConversion();
@@ -1530,7 +1530,7 @@ void CppGenerator::writeCustomConverterF
     s << "// Python to C++ conversions for type '" << customConversion->ownerType()->qualifiedCppName() << "'.\n";
     for (CustomConversion::TargetToNativeConversion *toNative : toCppConversions)
         writePythonToCppConversionFunctions(s, toNative, customConversion->ownerType());
-    s << Qt::endl;
+    s << endl;
 }
 
 void CppGenerator::writeConverterRegister(QTextStream &s, const AbstractMetaClass *metaClass,
@@ -1540,32 +1540,32 @@ void CppGenerator::writeConverterRegiste
         return;
     s << INDENT << "// Register Converter\n";
     s << INDENT << "SbkConverter *converter = Shiboken::Conversions::createConverter(";
-    s << cpythonTypeName(metaClass) << ',' << Qt::endl;
+    s << cpythonTypeName(metaClass) << ',' << endl;
     {
         Indentation indent(INDENT);
         QString sourceTypeName = metaClass->name();
         QString targetTypeName = sourceTypeName + QLatin1String("_PTR");
-        s << INDENT << pythonToCppFunctionName(sourceTypeName, targetTypeName) << ',' << Qt::endl;
-        s << INDENT << convertibleToCppFunctionName(sourceTypeName, targetTypeName) << ',' << Qt::endl;
+        s << INDENT << pythonToCppFunctionName(sourceTypeName, targetTypeName) << ',' << endl;
+        s << INDENT << convertibleToCppFunctionName(sourceTypeName, targetTypeName) << ',' << endl;
         std::swap(targetTypeName, sourceTypeName);
         s << INDENT << cppToPythonFunctionName(sourceTypeName, targetTypeName);
         if (metaClass->typeEntry()->isValue() || metaClass->typeEntry()->isSmartPointer()) {
-            s << ',' << Qt::endl;
+            s << ',' << endl;
             sourceTypeName = metaClass->name() + QLatin1String("_COPY");
             s << INDENT << cppToPythonFunctionName(sourceTypeName, targetTypeName);
         }
     }
     s << ");\n";
 
-    s << Qt::endl;
+    s << endl;
 
     QStringList cppSignature;
     if (!classContext.forSmartPointer()) {
         cppSignature = metaClass->qualifiedCppName().split(QLatin1String("::"),
-                                                                       Qt::SkipEmptyParts);
+                                                                       QString::SkipEmptyParts);
     } else {
         cppSignature = classContext.preciseType()->cppSignature().split(QLatin1String("::"),
-                                                                        Qt::SkipEmptyParts);
+                                                                        QString::SkipEmptyParts);
     }
     while (!cppSignature.isEmpty()) {
         QString signature = cppSignature.join(QLatin1String("::"));
@@ -1589,7 +1589,7 @@ void CppGenerator::writeConverterRegiste
         s << classContext.wrapperName() << ").name());\n";
     }
 
-    s << Qt::endl;
+    s << endl;
 
     if (!metaClass->typeEntry()->isValue() && !metaClass->typeEntry()->isSmartPointer())
         return;
@@ -1685,7 +1685,7 @@ void CppGenerator::writeMethodWrapperPre
 
             s << qualifiedCppName << " >()))\n";
             Indentation indent(INDENT);
-            s << INDENT << returnStatement(m_currentErrorCode) << Qt::endl << Qt::endl;
+            s << INDENT << returnStatement(m_currentErrorCode) << endl << endl;
         }
         // Declare pointer for the underlying C++ object.
         s << INDENT << "::";
@@ -1789,7 +1789,7 @@ void CppGenerator::writeConstructorWrapp
                 s << INDENT << "\"'" << metaClass->qualifiedCppName();
             }
             s << "' represents a C++ abstract class and cannot be instantiated\");\n";
-            s << INDENT << returnStatement(m_currentErrorCode) << Qt::endl;
+            s << INDENT << returnStatement(m_currentErrorCode) << endl;
         }
         s << INDENT<< "}\n\n";
     }
@@ -1808,24 +1808,24 @@ void CppGenerator::writeConstructorWrapp
 
     writeMethodWrapperPreamble(s, overloadData, classContext);
 
-    s << Qt::endl;
+    s << endl;
 
     if (overloadData.maxArgs() > 0)
         writeOverloadedFunctionDecisor(s, overloadData);
 
     writeFunctionCalls(s, overloadData, classContext);
-    s << Qt::endl;
+    s << endl;
 
     s << INDENT << "if (PyErr_Occurred() || !Shiboken::Object::setCppPointer(sbkSelf, Shiboken::SbkType< ::" << metaClass->qualifiedCppName() << " >(), cptr)) {\n";
     {
         Indentation indent(INDENT);
         s << INDENT << "delete cptr;\n";
-        s << INDENT << returnStatement(m_currentErrorCode) << Qt::endl;
+        s << INDENT << returnStatement(m_currentErrorCode) << endl;
     }
     s << INDENT << "}\n";
     if (overloadData.maxArgs() > 0) {
         s << INDENT << "if (!cptr) goto " << cpythonFunctionName(rfunc) << "_TypeError;\n";
-        s << Qt::endl;
+        s << endl;
     }
 
     s << INDENT << "Shiboken::Object::setValidCpp(sbkSelf, true);\n";
@@ -1847,13 +1847,13 @@ void CppGenerator::writeConstructorWrapp
 
     // Create metaObject and register signal/slot
     if (metaClass->isQObject() && usePySideExtensions()) {
-        s << Qt::endl << INDENT << "// QObject setup\n";
+        s << endl << INDENT << "// QObject setup\n";
         s << INDENT << "PySide::Signal::updateSourceObject(self);\n";
         s << INDENT << "metaObject = cptr->metaObject(); // <- init python qt properties\n";
         s << INDENT << "if (kwds && !PySide::fillQtProperties(self, metaObject, kwds, argNames, " << argNamesSet.count() << "))\n";
         {
             Indentation indentation(INDENT);
-            s << INDENT << returnStatement(m_currentErrorCode) << Qt::endl;
+            s << INDENT << returnStatement(m_currentErrorCode) << endl;
         }
     }
 
@@ -1876,7 +1876,7 @@ void CppGenerator::writeConstructorWrapp
             const CodeSnipList &injectedCodeSnips = func->injectedCodeSnips();
             for (const CodeSnip &cs : injectedCodeSnips) {
                 if (cs.position == TypeSystem::CodeSnipPositionEnd) {
-                    s << INDENT << "case " << metaClass->functions().indexOf(func) << ':' << Qt::endl;
+                    s << INDENT << "case " << metaClass->functions().indexOf(func) << ':' << endl;
                     s << INDENT << "{\n";
                     {
                         Indentation indent(INDENT);
@@ -1890,8 +1890,8 @@ void CppGenerator::writeConstructorWrapp
         s << "}\n";
     }
 
-    s << Qt::endl;
-    s << Qt::endl << INDENT << "return 1;\n";
+    s << endl;
+    s << endl << INDENT << "return 1;\n";
     if (overloadData.maxArgs() > 0)
         writeErrorSection(s, overloadData);
     s<< "}\n\n";
@@ -1916,7 +1916,7 @@ void CppGenerator::writeMethodWrapper(QT
 
     writeMethodWrapperPreamble(s, overloadData, classContext);
 
-    s << Qt::endl;
+    s << endl;
 
     /*
      * This code is intended for shift operations only:
@@ -1984,10 +1984,10 @@ void CppGenerator::writeMethodWrapper(QT
 
     if (!reverseIndent.isNull()) { // binary shift operator
         reverseIndent.reset();
-        s << Qt::endl << INDENT << "} // End of \"if (!" << PYTHON_RETURN_VAR << ")\"\n";
+        s << endl << INDENT << "} // End of \"if (!" << PYTHON_RETURN_VAR << ")\"\n";
     }
 
-    s << Qt::endl;
+    s << endl;
 
     writeFunctionReturnErrorCheckSection(s, hasReturnValue && !rfunc->isInplaceOperator());
 
@@ -2019,9 +2019,9 @@ void CppGenerator::writeArgumentsInitial
 
     s << INDENT << "PyObject *";
     s << PYTHON_ARGS << "[] = {"
-        << QString(maxArgs, QLatin1Char('0')).split(QLatin1String(""), Qt::SkipEmptyParts).join(QLatin1String(", "))
+        << QString(maxArgs, QLatin1Char('0')).split(QLatin1String(""), QString::SkipEmptyParts).join(QLatin1String(", "))
         << "};\n";
-    s << Qt::endl;
+    s << endl;
 
     if (overloadData.hasVarargs()) {
         maxArgs--;
@@ -2032,7 +2032,7 @@ void CppGenerator::writeArgumentsInitial
         s << INDENT << "Shiboken::AutoDecRef auto_nonvarargs(nonvarargs);\n";
         s << INDENT << PYTHON_ARGS << '[' << maxArgs << "] = PyTuple_GetSlice(args, " << maxArgs << ", numArgs);\n";
         s << INDENT << "Shiboken::AutoDecRef auto_varargs(" << PYTHON_ARGS << "[" << maxArgs << "]);\n";
-        s << Qt::endl;
+        s << endl;
     }
 
     bool usesNamedArguments = overloadData.hasArgumentWithDefaultValue();
@@ -2045,7 +2045,7 @@ void CppGenerator::writeArgumentsInitial
             {
                 Indentation indent(INDENT);
                 s << INDENT << "PyErr_SetString(PyExc_TypeError, \"" << fullPythonFunctionName(rfunc) << "(): too many arguments\");\n";
-                s << INDENT << returnStatement(m_currentErrorCode) << Qt::endl;
+                s << INDENT << returnStatement(m_currentErrorCode) << endl;
             }
             s << INDENT << '}';
         }
@@ -2058,7 +2058,7 @@ void CppGenerator::writeArgumentsInitial
             {
                 Indentation indent(INDENT);
                 s << INDENT << "PyErr_SetString(PyExc_TypeError, \"" << fullPythonFunctionName(rfunc) << "(): not enough arguments\");\n";
-                s << INDENT << returnStatement(m_currentErrorCode) << Qt::endl;
+                s << INDENT << returnStatement(m_currentErrorCode) << endl;
             }
             s << INDENT << '}';
         }
@@ -2076,7 +2076,7 @@ void CppGenerator::writeArgumentsInitial
         Indentation indent(INDENT);
         s << INDENT << "goto " << cpythonFunctionName(rfunc) << "_TypeError;";
     }
-    s << Qt::endl << Qt::endl;
+    s << endl << endl;
 
     QString funcName;
     if (rfunc->isOperatorOverload())
@@ -2095,9 +2095,9 @@ void CppGenerator::writeArgumentsInitial
     s << "))\n";
     {
         Indentation indent(INDENT);
-        s << INDENT << returnStatement(m_currentErrorCode) << Qt::endl;
+        s << INDENT << returnStatement(m_currentErrorCode) << endl;
     }
-    s << Qt::endl;
+    s << endl;
 }
 
 void CppGenerator::writeCppSelfConversion(QTextStream &s, const GeneratorContext &context,
@@ -2189,7 +2189,7 @@ void CppGenerator::writeCppSelfDefinitio
 void CppGenerator::writeErrorSection(QTextStream &s, OverloadData &overloadData)
 {
     const AbstractMetaFunction *rfunc = overloadData.referenceFunction();
-    s << Qt::endl << INDENT << cpythonFunctionName(rfunc) << "_TypeError:\n";
+    s << endl << INDENT << cpythonFunctionName(rfunc) << "_TypeError:\n";
     Indentation indentation(INDENT);
     QString funcName = fullPythonFunctionName(rfunc);
 
@@ -2209,7 +2209,7 @@ void CppGenerator::writeFunctionReturnEr
         Indentation indent(INDENT);
         if (hasReturnValue)
             s << INDENT << "Py_XDECREF(" << PYTHON_RETURN_VAR << ");\n";
-        s << INDENT << returnStatement(m_currentErrorCode) << Qt::endl;
+        s << INDENT << returnStatement(m_currentErrorCode) << endl;
     }
     s << INDENT << "}\n";
 }
@@ -2218,7 +2218,7 @@ void CppGenerator::writeInvalidPyObjectC
 {
     s << INDENT << "if (!Shiboken::Object::isValid(" << pyObj << "))\n";
     Indentation indent(INDENT);
-    s << INDENT << returnStatement(m_currentErrorCode) << Qt::endl;
+    s << INDENT << returnStatement(m_currentErrorCode) << endl;
 }
 
 static QString pythonToCppConverterForArgumentName(const QString &argumentName)
@@ -2494,7 +2494,7 @@ void CppGenerator::writePythonToCppTypeC
 
     if (!defaultValue.isEmpty())
         s << INDENT << '}';
-    s << Qt::endl;
+    s << endl;
 }
 
 static void addConversionRuleCodeSnippet(CodeSnipList &snippetList, QString &rule,
@@ -2557,10 +2557,10 @@ void CppGenerator::writeOverloadedFuncti
             s << "static ";
         if (const auto *decl = func->declaringClass())
             s << decl->name() << "::";
-        s << func->minimalSignature() << Qt::endl;
+        s << func->minimalSignature() << endl;
     }
     writeOverloadedFunctionDecisorEngine(s, &overloadData);
-    s << Qt::endl;
+    s << endl;
 
     // Ensure that the direct overload that called this reverse
     // is called.
@@ -2576,7 +2576,7 @@ void CppGenerator::writeOverloadedFuncti
 
     s << INDENT << "// Function signature not found.\n";
     s << INDENT << "if (overloadId == -1) goto " << cpythonFunctionName(overloadData.referenceFunction()) << "_TypeError;\n";
-    s << Qt::endl;
+    s << endl;
 }
 
 void CppGenerator::writeOverloadedFunctionDecisorEngine(QTextStream &s, const OverloadData *parentOverloadData)
@@ -2607,7 +2607,7 @@ void CppGenerator::writeOverloadedFuncti
     // Functions without arguments are identified right away.
     if (maxArgs == 0) {
         s << INDENT << "overloadId = " << parentOverloadData->headOverloadData()->overloads().indexOf(referenceFunction);
-        s << "; // " << referenceFunction->minimalSignature() << Qt::endl;
+        s << "; // " << referenceFunction->minimalSignature() << endl;
         return;
 
     }
@@ -2623,7 +2623,7 @@ void CppGenerator::writeOverloadedFuncti
         if (isLastArgument || (signatureFound && !hasDefaultCall)) {
             const AbstractMetaFunction *func = parentOverloadData->referenceFunction();
             s << INDENT << "overloadId = " << parentOverloadData->headOverloadData()->overloads().indexOf(func);
-            s << "; // " << func->minimalSignature() << Qt::endl;
+            s << "; // " << func->minimalSignature() << endl;
             return;
         }
     }
@@ -2649,7 +2649,7 @@ void CppGenerator::writeOverloadedFuncti
                 }
             }
             s << INDENT << "overloadId = " << parentOverloadData->headOverloadData()->overloads().indexOf(func);
-            s << "; // " << func->minimalSignature() << Qt::endl;
+            s << "; // " << func->minimalSignature() << endl;
         }
         s << INDENT << '}';
     }
@@ -2730,7 +2730,7 @@ void CppGenerator::writeOverloadedFuncti
             Indentation indent(INDENT);
             QString separator;
             QTextStream sep(&separator);
-            sep << Qt::endl << INDENT << "&& ";
+            sep << endl << INDENT << "&& ";
             s << typeChecks.join(separator);
         }
         s << ") {\n";
@@ -2740,7 +2740,7 @@ void CppGenerator::writeOverloadedFuncti
         }
         s << INDENT << "}";
     }
-    s << Qt::endl;
+    s << endl;
 }
 
 void CppGenerator::writeFunctionCalls(QTextStream &s, const OverloadData &overloadData,
@@ -2756,7 +2756,7 @@ void CppGenerator::writeFunctionCalls(QT
         } else {
             for (int i = 0; i < overloads.count(); i++) {
                 const AbstractMetaFunction *func = overloads.at(i);
-                s << INDENT << "case " << i << ": // " << func->signature() << Qt::endl;
+                s << INDENT << "case " << i << ": // " << func->signature() << endl;
                 s << INDENT << "{\n";
                 {
                     Indentation indent(INDENT);
@@ -2791,7 +2791,7 @@ void CppGenerator::writeSingleFunctionCa
         s << INDENT << "PyErr_Format(PyExc_TypeError, \"%s is a private method.\", \""
           << func->signature().replace(QLatin1String("::"), QLatin1String("."))
           << "\");\n";
-        s << INDENT << returnStatement(m_currentErrorCode) << Qt::endl;
+        s << INDENT << returnStatement(m_currentErrorCode) << endl;
         return;
     }
 
@@ -2834,7 +2834,7 @@ void CppGenerator::writeSingleFunctionCa
         writeArgumentConversion(s, argType, argName, pyArgName, func->implementingClass(), defaultValue, func->isUserAdded());
     }
 
-    s << Qt::endl;
+    s << endl;
 
     int numRemovedArgs = OverloadData::numberOfRemovedArguments(func);
 
@@ -2991,7 +2991,7 @@ void CppGenerator::writePythonToCppConve
     if (conversion.isEmpty())
         conversion = QLatin1Char('*') + cpythonWrapperCPtr(sourceType->typeEntry(), QLatin1String("pyIn"));
     if (!preConversion.isEmpty())
-        c << nested << preConversion << Qt::endl;
+        c << nested << preConversion << endl;
     const QString fullTypeName = getFullTypeName(targetType->typeEntry());
     c << nested << "*reinterpret_cast<" << fullTypeName << " *>(cppOut) = "
         << fullTypeName << '(' << conversion << ");";
@@ -3003,7 +3003,7 @@ void CppGenerator::writePythonToCppConve
     if (typeCheck.isEmpty())
         typeCheck = QString::fromLatin1("PyObject_TypeCheck(pyIn, %1)").arg(sourcePyType);
     writeIsPythonConvertibleToCppFunction(s, sourceTypeName, targetTypeName, typeCheck);
-    s << Qt::endl;
+    s << endl;
 }
 
 void CppGenerator::writePythonToCppConversionFunctions(QTextStream &s,
@@ -3110,15 +3110,15 @@ void CppGenerator::writePythonToCppConve
     else
         typeCheck = QString::fromLatin1("%1pyIn)").arg(typeCheck);
     writeIsPythonConvertibleToCppFunction(s, typeName, typeName, typeCheck);
-    s << Qt::endl;
+    s << endl;
 }
 
 void CppGenerator::writeAddPythonToCppConversion(QTextStream &s, const QString &converterVar, const QString &pythonToCppFunc, const QString &isConvertibleFunc)
 {
-    s << INDENT << "Shiboken::Conversions::addPythonToCppValueConversion(" << converterVar << ',' << Qt::endl;
+    s << INDENT << "Shiboken::Conversions::addPythonToCppValueConversion(" << converterVar << ',' << endl;
     {
         Indentation indent(INDENT);
-        s << INDENT << pythonToCppFunc << ',' << Qt::endl;
+        s << INDENT << pythonToCppFunc << ',' << endl;
         s << INDENT << isConvertibleFunc;
     }
     s << ");\n";
@@ -3149,8 +3149,8 @@ void CppGenerator::writeNamedArgumentRes
                 s << INDENT << "if (value && " << pyArgName << ") {\n";
                 {
                     Indentation indent(INDENT);
-                    s << INDENT << pyErrString.arg(arg->name()) << Qt::endl;
-                    s << INDENT << returnStatement(m_currentErrorCode) << Qt::endl;
+                    s << INDENT << pyErrString.arg(arg->name()) << endl;
+                    s << INDENT << returnStatement(m_currentErrorCode) << endl;
                 }
                 s << INDENT << "}\n";
                 s << INDENT << "if (value) {\n";
@@ -3225,7 +3225,7 @@ static QStringList defaultExceptionHandl
 void CppGenerator::writeMethodCall(QTextStream &s, const AbstractMetaFunction *func,
                                    const GeneratorContext &context, int maxArgs)
 {
-    s << INDENT << "// " << func->minimalSignature() << (func->isReverseOperator() ? " [reverse operator]": "") << Qt::endl;
+    s << INDENT << "// " << func->minimalSignature() << (func->isReverseOperator() ? " [reverse operator]": "") << endl;
     if (func->isConstructor()) {
         const CodeSnipList &snips = func->injectedCodeSnips();
         for (const CodeSnip &cs : snips) {
@@ -3245,7 +3245,7 @@ void CppGenerator::writeMethodCall(QText
             Indentation indent(INDENT);
             s << INDENT << "PyErr_SetString(PyExc_NotImplementedError, \"pure virtual method '";
             s << func->ownerClass()->name() << '.' << func->name() << "()' not implemented.\");\n";
-            s << INDENT << returnStatement(m_currentErrorCode) << Qt::endl;
+            s << INDENT << returnStatement(m_currentErrorCode) << endl;
         }
         s << INDENT << "}\n";
     }
@@ -3363,7 +3363,7 @@ void CppGenerator::writeMethodCall(QText
                     std::swap(firstArg, secondArg);
 
                 if (((op == QLatin1String("++")) || (op == QLatin1String("--"))) && !func->isReverseOperator())  {
-                    s << Qt::endl << INDENT << "for (int i=0; i < " << secondArg << "; i++, " << firstArg << op << ");\n";
+                    s << endl << INDENT << "for (int i=0; i < " << secondArg << "; i++, " << firstArg << op << ");\n";
                     mc << firstArg;
                 } else {
                     mc << firstArg << ' ' << op << ' ' << secondArg;
@@ -3393,7 +3393,7 @@ void CppGenerator::writeMethodCall(QText
                                 << ctorCall << ";\n"
                                 << INDENT
                                 << "PySide::setNextQObjectMemoryAddr(0);"
-                                << Qt::endl;
+                                << endl;
                         }
                         uva << INDENT << "} else {\n";
                         {
@@ -3497,12 +3497,12 @@ void CppGenerator::writeMethodCall(QText
                         << INDENT << "threadSaver.save();\n";
                 }
             } else if (allowThread) {
-                s << INDENT << BEGIN_ALLOW_THREADS << Qt::endl;
+                s << INDENT << BEGIN_ALLOW_THREADS << endl;
             }
             s << INDENT;
             if (isCtor) {
                 s << (useVAddr.isEmpty() ?
-                      QString::fromLatin1("cptr = %1;").arg(methodCall) : useVAddr) << Qt::endl;
+                      QString::fromLatin1("cptr = %1;").arg(methodCall) : useVAddr) << endl;
             } else if (func->type() && !func->isInplaceOperator()) {
                 bool writeReturnType = true;
                 if (avoidProtectedHack()) {
@@ -3586,12 +3586,12 @@ void CppGenerator::writeMethodCall(QText
         hasReturnPolicy = true;
 
     if (!ownership_mods.isEmpty()) {
-        s << Qt::endl << INDENT << "// Ownership transferences.\n";
+        s << endl << INDENT << "// Ownership transferences.\n";
         for (const ArgumentModification &arg_mod : qAsConst(ownership_mods)) {
             const AbstractMetaClass *wrappedClass = nullptr;
             QString pyArgName = argumentNameFromIndex(func, arg_mod.index, &wrappedClass);
             if (!wrappedClass) {
-                s << "#error Invalid ownership modification for argument " << arg_mod.index << '(' << pyArgName << ")\n" << Qt::endl;
+                s << "#error Invalid ownership modification for argument " << arg_mod.index << '(' << pyArgName << ")\n" << endl;
                 break;
             }
 
@@ -3614,7 +3614,7 @@ void CppGenerator::writeMethodCall(QText
             } else {
                 s << "invalidate(" << pyArgName << ");";
             }
-            s << Qt::endl;
+            s << endl;
         }
 
     } else if (!refcount_mods.isEmpty()) {
@@ -3634,7 +3634,7 @@ void CppGenerator::writeMethodCall(QText
             } else {
                 pyArgName = argumentNameFromIndex(func, arg_mod.index, &wrappedClass);
                 if (pyArgName.isEmpty()) {
-                    s << "#error Invalid reference count modification for argument " << arg_mod.index << Qt::endl << Qt::endl;
+                    s << "#error Invalid reference count modification for argument " << arg_mod.index << endl << endl;
                     break;
                 }
             }
@@ -3705,9 +3705,9 @@ void CppGenerator::writeMultipleInherita
         for (const QString &ancestor : ancestors)
             s << INDENT << "offsets.insert(int(" << ancestor << "));\n";
 
-        s << Qt::endl;
+        s << endl;
         s << INDENT << "offsets.erase(0);\n";
-        s << Qt::endl;
+        s << endl;
 
         s << INDENT << "std::copy(offsets.cbegin(), offsets.cend(), mi_offsets);\n";
     }
@@ -3775,7 +3775,7 @@ void CppGenerator::writeEnumConverterIni
     {
         Indentation indent(INDENT);
         QString typeName = fixedCppTypeName(enumType);
-        s << INDENT << "SbkConverter *converter = Shiboken::Conversions::createConverter(" << enumPythonType << ',' << Qt::endl;
+        s << INDENT << "SbkConverter *converter = Shiboken::Conversions::createConverter(" << enumPythonType << ',' << endl;
         {
             Indentation indent(INDENT);
             s << INDENT << cppToPythonFunctionName(typeName, typeName) << ");\n";
@@ -3860,7 +3860,7 @@ void CppGenerator::writeContainerConvert
 void CppGenerator::writeExtendedConverterInitialization(QTextStream &s, const TypeEntry *externalType,
                                                         const QVector<const AbstractMetaClass *>& conversions)
 {
-    s << INDENT << "// Extended implicit conversions for " << externalType->qualifiedTargetLangName() << '.' << Qt::endl;
+    s << INDENT << "// Extended implicit conversions for " << externalType->qualifiedTargetLangName() << '.' << endl;
     for (const AbstractMetaClass *sourceClass : conversions) {
         const QString converterVar = QLatin1String("reinterpret_cast<SbkObjectType *>(")
             + cppApiVariableName(externalType->targetLangPackage()) + QLatin1Char('[')
@@ -4045,7 +4045,7 @@ void CppGenerator::writeClassDefinition(
         if (metaClass == miClass)
             writeMultipleInheritanceInitializerFunction(s, metaClass);
         writeSpecialCastFunction(s, metaClass);
-        s << Qt::endl;
+        s << endl;
     }
 
     s << "// Class Definition -----------------------------------------------\n";
@@ -4074,7 +4074,7 @@ void CppGenerator::writeClassDefinition(
     s << "{\n";
     s << INDENT << "return " << typePtr << ";\n";
     s << "}\n";
-    s << Qt::endl;
+    s << endl;
     s << "static PyType_Slot " << className << "_slots[] = {\n";
     s << INDENT << "{Py_tp_base,        nullptr}, // inserted by introduceWrapperType\n";
     s << INDENT << pyTypeSlotEntry("Py_tp_dealloc", tp_dealloc)
@@ -4117,8 +4117,8 @@ void CppGenerator::writeClassDefinition(
     s << INDENT << tp_flags << ",\n";
     s << INDENT << className << "_slots\n";
     s << "};\n";
-    s << Qt::endl;
-    s << "} //extern \"C\""  << Qt::endl;
+    s << endl;
+    s << "} //extern \"C\""  << endl;
 }
 
 void CppGenerator::writeMappingMethods(QTextStream &s,
@@ -4351,7 +4351,7 @@ void CppGenerator::writeCopyFunction(QTe
     writeFunctionReturnErrorCheckSection(s);
     s << INDENT << "return " << PYTHON_RETURN_VAR << ";\n";
     s << "}\n";
-    s << Qt::endl;
+    s << endl;
 }
 
 void CppGenerator::writeGetterFunction(QTextStream &s,
@@ -4490,7 +4490,7 @@ void CppGenerator::writeSetterFunction(Q
         s << cppField << ";\n";
         s << INDENT << PYTHON_TO_CPP_VAR << "(pyIn, &cppOut_ptr)";
     }
-    s << ";\n" << Qt::endl;
+    s << ";\n" << endl;
 
     if (isPointerToWrapperType(fieldType)) {
         s << INDENT << "Shiboken::Object::keepReference(reinterpret_cast<SbkObject *>(self), \"";
@@ -4513,7 +4513,7 @@ void CppGenerator::writeRichCompareFunct
     s << INDENT << "PyObject *" << PYTHON_RETURN_VAR << "{};\n";
     s << INDENT << "PythonToCppFunc " << PYTHON_TO_CPP_VAR << ";\n";
     writeUnusedVariableCast(s, QLatin1String(PYTHON_TO_CPP_VAR));
-    s << Qt::endl;
+    s << endl;
 
     s << INDENT << "switch (op) {\n";
     {
@@ -4523,7 +4523,7 @@ void CppGenerator::writeRichCompareFunct
             const AbstractMetaFunction *rfunc = overloads[0];
 
             QString operatorId = ShibokenGenerator::pythonRichCompareOperatorId(rfunc);
-            s << INDENT << "case " << operatorId << ':' << Qt::endl;
+            s << INDENT << "case " << operatorId << ':' << endl;
 
             Indentation indent(INDENT);
 
@@ -4558,7 +4558,7 @@ void CppGenerator::writeRichCompareFunct
                 s << ") {\n";
                 {
                     Indentation indent(INDENT);
-                    s << INDENT << "// " << func->signature() << Qt::endl;
+                    s << INDENT << "// " << func->signature() << endl;
                     writeArgumentConversion(s, argType, QLatin1String(CPP_ARG0),
                                             QLatin1String(PYTHON_ARG), metaClass,
                                             QString(), func->isUserAdded());
@@ -4627,7 +4627,7 @@ void CppGenerator::writeRichCompareFunct
     }
     s << INDENT << baseName << "_RichComparison_TypeError:\n";
     s << INDENT << "PyErr_SetString(PyExc_NotImplementedError, \"operator not implemented.\");\n";
-    s << INDENT << returnStatement(m_currentErrorCode) << Qt::endl << Qt::endl;
+    s << INDENT << returnStatement(m_currentErrorCode) << endl << endl;
     s<< "}\n\n";
 }
 
@@ -4671,7 +4671,7 @@ void CppGenerator::writeMethodDefinition
         writeMethodDefinitionEntry(s, overloads);
         s << '}';
     }
-    s << ',' << Qt::endl;
+    s << ',' << endl;
 }
 
 void CppGenerator::writeSignatureInfo(QTextStream &s, const AbstractMetaFunctionList &overloads)
@@ -4706,7 +4706,7 @@ void CppGenerator::writeSignatureInfo(QT
         s << funcName << '(' << args.join(QLatin1Char(',')) << ')';
         if (f->type())
             s << "->" << f->type()->pythonSignature();
-        s << Qt::endl;
+        s << endl;
     }
 }
 
@@ -4766,7 +4766,7 @@ void CppGenerator::writeEnumInitializati
 
         s << INDENT << enumVarTypeObj << " = Shiboken::Enum::";
         s << ((enclosingClass || hasUpperEnclosingClass) ? "createScopedEnum" : "createGlobalEnum");
-        s << '(' << enclosingObjectVariable << ',' << Qt::endl;
+        s << '(' << enclosingObjectVariable << ',' << endl;
         {
             Indentation indent(INDENT);
             s << INDENT << '"' << cppEnum->name() << "\",\n";
@@ -4774,13 +4774,13 @@ void CppGenerator::writeEnumInitializati
             s << INDENT << '"' << (cppEnum->enclosingClass() ? (cppEnum->enclosingClass()->qualifiedCppName() + QLatin1String("::")) : QString());
             s << cppEnum->name() << '"';
             if (flags)
-                s << ',' << Qt::endl << INDENT << cpythonTypeNameExt(flags);
+                s << ',' << endl << INDENT << cpythonTypeNameExt(flags);
             s << ");\n";
         }
         s << INDENT << "if (!" << cpythonTypeNameExt(cppEnum->typeEntry()) << ")\n";
         {
             Indentation indent(INDENT);
-            s << INDENT << returnStatement(m_currentErrorCode) << Qt::endl << Qt::endl;
+            s << INDENT << returnStatement(m_currentErrorCode) << endl << endl;
         }
     }
 
@@ -4813,7 +4813,7 @@ void CppGenerator::writeEnumInitializati
                         << "))->tp_dict, \"" << mangleName(enumValue->name()) << "\", anonEnumItem) < 0)\n";
                     {
                         Indentation indent(INDENT);
-                        s << INDENT << returnStatement(m_currentErrorCode) << Qt::endl;
+                        s << INDENT << returnStatement(m_currentErrorCode) << endl;
                     }
                     s << INDENT << "Py_DECREF(anonEnumItem);\n";
                 }
@@ -4823,27 +4823,27 @@ void CppGenerator::writeEnumInitializati
                 s << enumValueText << ") < 0)\n";
                 {
                     Indentation indent(INDENT);
-                    s << INDENT << returnStatement(m_currentErrorCode) << Qt::endl;
+                    s << INDENT << returnStatement(m_currentErrorCode) << endl;
                 }
             }
             break;
         case CEnum: {
             s << INDENT << "if (!Shiboken::Enum::";
             s << ((enclosingClass || hasUpperEnclosingClass) ? "createScopedEnumItem" : "createGlobalEnumItem");
-            s << '(' << enumVarTypeObj << ',' << Qt::endl;
+            s << '(' << enumVarTypeObj << ',' << endl;
             Indentation indent(INDENT);
             s << INDENT << enclosingObjectVariable << ", \"" << mangleName(enumValue->name()) << "\", ";
             s << enumValueText << "))\n";
-            s << INDENT << returnStatement(m_currentErrorCode) << Qt::endl;
+            s << INDENT << returnStatement(m_currentErrorCode) << endl;
         }
             break;
         case EnumClass: {
             s << INDENT << "if (!Shiboken::Enum::createScopedEnumItem("
-                << enumVarTypeObj << ',' << Qt::endl;
+                << enumVarTypeObj << ',' << endl;
             Indentation indent(INDENT);
             s << INDENT << enumVarTypeObj<< ", \"" << mangleName(enumValue->name()) << "\", "
                << enumValueText << "))\n"
-               << INDENT << returnStatement(m_currentErrorCode) << Qt::endl;
+               << INDENT << returnStatement(m_currentErrorCode) << endl;
         }
             break;
         }
@@ -4854,7 +4854,7 @@ void CppGenerator::writeEnumInitializati
     s << INDENT << "// End of '" << cppEnum->name() << "' enum";
     if (cppEnum->typeEntry()->flags())
         s << "/flags";
-    s << '.' << Qt::endl << Qt::endl;
+    s << '.' << endl << endl;
 }
 
 void CppGenerator::writeSignalInitialization(QTextStream &s, const AbstractMetaClass *metaClass)
@@ -4922,7 +4922,7 @@ void CppGenerator::writeFlagsMethods(QTe
     writeFlagsToLong(s, cppEnum);
     writeFlagsNonZero(s, cppEnum);
 
-    s << Qt::endl;
+    s << endl;
 }
 
 void CppGenerator::writeFlagsNumberMethodsDefinition(QTextStream &s, const AbstractMetaEnum *cppEnum)
@@ -5066,7 +5066,7 @@ void CppGenerator::writeClassRegister(QT
     const AbstractMetaClassList baseClasses = getBaseClasses(metaClass);
     if (metaClass->baseClassNames().size() > 1) {
         s << INDENT << "PyObject *" << pyTypeBasesVariable
-            << " = PyTuple_Pack(" << baseClasses.size() << ',' << Qt::endl;
+            << " = PyTuple_Pack(" << baseClasses.size() << ',' << endl;
         Indentation indent(INDENT);
         for (int i = 0, size = baseClasses.size(); i < size; ++i) {
             if (i)
@@ -5140,7 +5140,7 @@ void CppGenerator::writeClassRegister(QT
 
         // 8:baseTypes
         if (metaClass->baseClassNames().size() > 1)
-            s << INDENT << pyTypeBasesVariable << ',' << Qt::endl;
+            s << INDENT << pyTypeBasesVariable << ',' << endl;
         else
             s << INDENT << "0,\n";
 
@@ -5156,25 +5156,25 @@ void CppGenerator::writeClassRegister(QT
             s << INDENT << wrapperFlags.join(" | ");
     }
     s << INDENT << ");\n";
-    s << INDENT << Qt::endl;
+    s << INDENT << endl;
 
     if (!classContext.forSmartPointer())
-        s << INDENT << cpythonTypeNameExt(classTypeEntry) << Qt::endl;
+        s << INDENT << cpythonTypeNameExt(classTypeEntry) << endl;
     else
-        s << INDENT << cpythonTypeNameExt(classContext.preciseType()) << Qt::endl;
+        s << INDENT << cpythonTypeNameExt(classContext.preciseType()) << endl;
     s << INDENT << "    = reinterpret_cast<PyTypeObject *>(" << pyTypeName << ");\n";
-    s << Qt::endl;
+    s << endl;
 
     // Register conversions for the type.
     writeConverterRegister(s, metaClass, classContext);
-    s << Qt::endl;
+    s << endl;
 
     // class inject-code target/beginning
     if (!classTypeEntry->codeSnips().isEmpty()) {
         writeClassCodeSnips(s, classTypeEntry->codeSnips(),
                             TypeSystem::CodeSnipPositionBeginning, TypeSystem::TargetLangCode,
                             classContext);
-        s << Qt::endl;
+        s << endl;
     }
 
     // Fill multiple inheritance data, if needed.
@@ -5220,11 +5220,11 @@ void CppGenerator::writeClassRegister(QT
         writeToPythonConversion(s, field->type(), metaClass, metaClass->qualifiedCppName() + QLatin1String("::") + field->name());
         s << ");\n";
     }
-    s << Qt::endl;
+    s << endl;
 
     // class inject-code target/end
     if (!classTypeEntry->codeSnips().isEmpty()) {
-        s << Qt::endl;
+        s << endl;
         writeClassCodeSnips(s, classTypeEntry->codeSnips(),
                             TypeSystem::CodeSnipPositionEnd, TypeSystem::TargetLangCode,
                             classContext);
@@ -5692,7 +5692,7 @@ bool CppGenerator::finishGeneration()
     QTextStream &s = file.stream;
 
     // write license comment
-    s << licenseComment() << Qt::endl;
+    s << licenseComment() << endl;
 
     s << "#include <sbkpython.h>\n";
     s << "#include <shiboken.h>\n";
@@ -5706,10 +5706,10 @@ bool CppGenerator::finishGeneration()
         s << "#include <qapp_macro.h>\n";
     }
 
-    s << "#include \"" << getModuleHeaderFileName() << '"' << Qt::endl << Qt::endl;
+    s << "#include \"" << getModuleHeaderFileName() << '"' << endl << endl;
     for (const Include &include : qAsConst(includes))
         s << include;
-    s << Qt::endl;
+    s << endl;
 
     // Global enums
     AbstractMetaEnumList globalEnums = this->globalEnums();
@@ -5725,14 +5725,14 @@ bool CppGenerator::finishGeneration()
     Q_ASSERT(moduleEntry);
 
     //Extra includes
-    s << Qt::endl << "// Extra includes\n";
+    s << endl << "// Extra includes\n";
     QVector<Include> extraIncludes = moduleEntry->extraIncludes();
     for (AbstractMetaEnum *cppEnum : qAsConst(globalEnums))
         extraIncludes.append(cppEnum->typeEntry()->extraIncludes());
     std::sort(extraIncludes.begin(), extraIncludes.end());
     for (const Include &inc : qAsConst(extraIncludes))
         s << inc;
-    s << Qt::endl;
+    s << endl;
 
     s << "// Current module's type array.\n";
     s << "PyTypeObject **" << cppApiVariableName() << " = nullptr;\n";
@@ -5771,7 +5771,7 @@ bool CppGenerator::finishGeneration()
 
     s << "// Global functions ";
     s << "------------------------------------------------------------\n";
-    s << globalFunctionImpl << Qt::endl;
+    s << globalFunctionImpl << endl;
 
     s << "static PyMethodDef " << moduleName() << "_methods[] = {\n";
     s << globalFunctionDecl;
@@ -5779,7 +5779,7 @@ bool CppGenerator::finishGeneration()
 
     s << "// Classes initialization functions ";
     s << "------------------------------------------------------------\n";
-    s << classInitDecl << Qt::endl;
+    s << classInitDecl << endl;
 
     if (!globalEnums.isEmpty()) {
         QString converterImpl;
@@ -5791,14 +5791,14 @@ bool CppGenerator::finishGeneration()
             if (cppEnum->isAnonymous() || cppEnum->isPrivate())
                 continue;
             writeEnumConverterFunctions(s, cppEnum);
-            s << Qt::endl;
+            s << endl;
         }
 
         if (!converterImpl.isEmpty()) {
             s << "// Enum converters ";
             s << "------------------------------------------------------------\n";
             s << "namespace Shiboken\n{\n";
-            s << converterImpl << Qt::endl;
+            s << converterImpl << endl;
             s << "} // namespace Shiboken\n\n";
         }
     }
@@ -5810,16 +5810,16 @@ bool CppGenerator::finishGeneration()
         s << "PyTypeObject **" << cppApiVariableName(requiredModule) << ";\n";
         s << "SbkConverter **" << convertersVariableName(requiredModule) << ";\n";
     }
-    s << Qt::endl;
+    s << endl;
 
     s << "// Module initialization ";
     s << "------------------------------------------------------------\n";
     ExtendedConverterData extendedConverters = getExtendedConverters();
     if (!extendedConverters.isEmpty()) {
-        s << Qt::endl << "// Extended Converters.\n\n";
+        s << endl << "// Extended Converters.\n\n";
         for (ExtendedConverterData::const_iterator it = extendedConverters.cbegin(), end = extendedConverters.cend(); it != end; ++it) {
             const TypeEntry *externalType = it.key();
-            s << "// Extended implicit conversions for " << externalType->qualifiedTargetLangName() << '.' << Qt::endl;
+            s << "// Extended implicit conversions for " << externalType->qualifiedTargetLangName() << '.' << endl;
             for (const AbstractMetaClass *sourceClass : it.value()) {
                 AbstractMetaType *sourceType = buildAbstractMetaTypeFromAbstractMetaClass(sourceClass);
                 AbstractMetaType *targetType = buildAbstractMetaTypeFromTypeEntry(externalType);
@@ -5830,13 +5830,13 @@ bool CppGenerator::finishGeneration()
 
     const QVector<const CustomConversion *> &typeConversions = getPrimitiveCustomConversions();
     if (!typeConversions.isEmpty()) {
-        s << Qt::endl << "// Primitive Type converters.\n\n";
+        s << endl << "// Primitive Type converters.\n\n";
         for (const CustomConversion *conversion : typeConversions) {
             s << "// C++ to Python conversion for type '" << conversion->ownerType()->qualifiedCppName() << "'.\n";
             writeCppToPythonFunction(s, conversion);
             writeCustomConverterFunctions(s, conversion);
         }
-        s << Qt::endl;
+        s << endl;
     }
 
     const QVector<const AbstractMetaType *> &containers = instantiatedContainers();
@@ -5846,7 +5846,7 @@ bool CppGenerator::finishGeneration()
             s << "// C++ to Python conversion for type '" << container->cppSignature() << "'.\n";
             writeContainerConverterFunctions(s, container);
         }
-        s << Qt::endl;
+        s << endl;
     }
 
     s << "#if defined _WIN32 || defined __CYGWIN__\n";
@@ -5925,26 +5925,26 @@ bool CppGenerator::finishGeneration()
     s << classPythonDefines;
 
     if (!typeConversions.isEmpty()) {
-        s << Qt::endl;
+        s << endl;
         for (const CustomConversion *conversion : typeConversions) {
             writePrimitiveConverterInitialization(s, conversion);
-            s << Qt::endl;
+            s << endl;
         }
     }
 
     if (!containers.isEmpty()) {
-        s << Qt::endl;
+        s << endl;
         for (const AbstractMetaType *container : containers) {
             writeContainerConverterInitialization(s, container);
-            s << Qt::endl;
+            s << endl;
         }
     }
 
     if (!extendedConverters.isEmpty()) {
-        s << Qt::endl;
+        s << endl;
         for (ExtendedConverterData::const_iterator it = extendedConverters.cbegin(), end = extendedConverters.cend(); it != end; ++it) {
             writeExtendedConverterInitialization(s, it.key(), it.value());
-            s << Qt::endl;
+            s << endl;
         }
     }
 
@@ -5959,7 +5959,7 @@ bool CppGenerator::finishGeneration()
         if (!referencedType)
             continue;
         QString converter = converterObject(referencedType);
-        QStringList cppSignature = pte->qualifiedCppName().split(QLatin1String("::"), Qt::SkipEmptyParts);
+        QStringList cppSignature = pte->qualifiedCppName().split(QLatin1String("::"), QString::SkipEmptyParts);
         while (!cppSignature.isEmpty()) {
             QString signature = cppSignature.join(QLatin1String("::"));
             s << INDENT << "Shiboken::Conversions::registerConverterName(" << converter << ", \"" << signature << "\");\n";
@@ -5967,12 +5967,12 @@ bool CppGenerator::finishGeneration()
         }
     }
 
-    s << Qt::endl;
+    s << endl;
     if (maxTypeIndex)
         s << INDENT << "Shiboken::Module::registerTypes(module, " << cppApiVariableName() << ");\n";
     s << INDENT << "Shiboken::Module::registerTypeConverters(module, " << convertersVariableName() << ");\n";
 
-    s << Qt::endl << INDENT << "if (PyErr_Occurred()) {\n";
+    s << endl << INDENT << "if (PyErr_Occurred()) {\n";
     {
         Indentation indentation(INDENT);
         s << INDENT << "PyErr_Print();\n";
@@ -6002,7 +6002,7 @@ bool CppGenerator::finishGeneration()
     s << INDENT << "FinishSignatureInitialization(module, " << moduleName()
         << "_SignatureStrings);\n";
 
-    s << Qt::endl;
+    s << endl;
     s << "SBK_MODULE_INIT_FUNCTION_END\n";
 
     return file.done() != FileOut::Failure;
@@ -6190,7 +6190,7 @@ void CppGenerator::writeIndexError(QText
     {
         Indentation indent(INDENT);
         s << INDENT << "PyErr_SetString(PyExc_IndexError, \"" << errorMsg << "\");\n";
-        s << INDENT << returnStatement(m_currentErrorCode) << Qt::endl;
+        s << INDENT << returnStatement(m_currentErrorCode) << endl;
     }
     s << INDENT << "}\n";
 }
Index: pyside-setup-opensource-src-5.15.1/sources/shiboken2/generator/shiboken2/headergenerator.cpp
===================================================================
--- pyside-setup-opensource-src-5.15.1.orig/sources/shiboken2/generator/shiboken2/headergenerator.cpp
+++ pyside-setup-opensource-src-5.15.1/sources/shiboken2/generator/shiboken2/headergenerator.cpp
@@ -119,7 +119,7 @@ void HeaderGenerator::generateClass(QTex
         s << "#define protected public\n\n";
 
     //Includes
-    s << metaClass->typeEntry()->include() << Qt::endl;
+    s << metaClass->typeEntry()->include() << endl;
 
     if (classContext.useWrapper() && usePySideExtensions() && metaClass->isQObject())
         s << "namespace PySide { class DynamicQMetaObject; }\n\n";
@@ -416,7 +416,7 @@ bool HeaderGenerator::finishGeneration()
     for (const AbstractMetaType *metaType : instantiatedSmartPtrs) {
         QString indexName = getTypeIndexVariableName(metaType);
         _writeTypeIndexValue(macrosStream, indexName, smartPointerCountIndex);
-        macrosStream << ", // " << metaType->cppSignature() << Qt::endl;
+        macrosStream << ", // " << metaType->cppSignature() << endl;
         // Add a the same value for const pointees (shared_ptr<const Foo>).
         const auto ptrName = metaType->typeEntry()->entryName();
         int pos = indexName.indexOf(ptrName, 0, Qt::CaseInsensitive);
@@ -460,7 +460,7 @@ bool HeaderGenerator::finishGeneration()
     const QVector<const AbstractMetaType *> &containers = instantiatedContainers();
     for (const AbstractMetaType *container : containers) {
         _writeTypeIndexValue(macrosStream, getTypeIndexVariableName(container), pCount);
-        macrosStream << ", // " << container->cppSignature() << Qt::endl;
+        macrosStream << ", // " << container->cppSignature() << endl;
         pCount++;
     }
 
@@ -528,10 +528,10 @@ bool HeaderGenerator::finishGeneration()
     FileOut file(moduleHeaderFileName);
     QTextStream &s = file.stream;
     // write license comment
-    s << licenseComment() << Qt::endl << Qt::endl;
+    s << licenseComment() << endl << endl;
 
-    s << "#ifndef " << includeShield << Qt::endl;
-    s << "#define " << includeShield << Qt::endl << Qt::endl;
+    s << "#ifndef " << includeShield << endl;
+    s << "#define " << includeShield << endl << endl;
     if (!avoidProtectedHack()) {
         s << "//workaround to access protected functions\n";
         s << "#define protected public\n\n";
@@ -545,7 +545,7 @@ bool HeaderGenerator::finishGeneration()
         s << "// Module Includes\n";
         for (const QString &requiredModule : qAsConst(requiredTargetImports))
             s << "#include <" << getModuleHeaderFileName(requiredModule) << ">\n";
-        s << Qt::endl;
+        s << endl;
     }
 
     s << "// Bound library includes\n";
@@ -557,7 +557,7 @@ bool HeaderGenerator::finishGeneration()
         const PrimitiveTypeEntryList &primitiveTypeList = primitiveTypes();
         for (const PrimitiveTypeEntry *ptype : primitiveTypeList)
             s << ptype->include();
-        s << Qt::endl;
+        s << endl;
     }
 
     if (!containerTypes().isEmpty()) {
@@ -565,24 +565,24 @@ bool HeaderGenerator::finishGeneration()
         const ContainerTypeEntryList &containerTypeList = containerTypes();
         for (const ContainerTypeEntry *ctype : containerTypeList)
             s << ctype->include();
-        s << Qt::endl;
+        s << endl;
     }
 
-    s << macros << Qt::endl;
+    s << macros << endl;
 
     if (!protectedEnumSurrogates.isEmpty()) {
         s << "// Protected enum surrogates\n";
-        s << protectedEnumSurrogates << Qt::endl;
+        s << protectedEnumSurrogates << endl;
     }
 
     s << "namespace Shiboken\n{\n\n";
 
     s << "// PyType functions, to get the PyObjectType for a type T\n";
-    s << sbkTypeFunctions << Qt::endl;
+    s << sbkTypeFunctions << endl;
 
     s << "} // namespace Shiboken\n\n";
 
-    s << "#endif // " << includeShield << Qt::endl << Qt::endl;
+    s << "#endif // " << includeShield << endl << endl;
 
     return file.done() != FileOut::Failure;
 }
Index: pyside-setup-opensource-src-5.15.1/sources/shiboken2/generator/shiboken2/shibokengenerator.cpp
===================================================================
--- pyside-setup-opensource-src-5.15.1.orig/sources/shiboken2/generator/shiboken2/shibokengenerator.cpp
+++ pyside-setup-opensource-src-5.15.1/sources/shiboken2/generator/shiboken2/shibokengenerator.cpp
@@ -97,7 +97,7 @@ static QString resolveScopePrefix(const
 
 static inline QStringList splitClassScope(const AbstractMetaClass *scope)
 {
-    return scope->qualifiedCppName().split(QLatin1String("::"), Qt::SkipEmptyParts);
+    return scope->qualifiedCppName().split(QLatin1String("::"), QString::SkipEmptyParts);
 }
 
 static QString resolveScopePrefix(const AbstractMetaClass *scope, const QString &value)
@@ -2833,7 +2833,7 @@ void ShibokenGenerator::writeMinimalCons
     } else {
         const QString message = msgCouldNotFindMinimalConstructor(QLatin1String(__FUNCTION__), type->qualifiedCppName());
         qCWarning(lcShiboken()).noquote() << message;
-        s << ";\n#error " << message << Qt::endl;
+        s << ";\n#error " << message << endl;
     }
 }
 
Index: pyside-setup-opensource-src-5.15.1/sources/shiboken2/ApiExtractor/typedatabase.cpp
===================================================================
--- pyside-setup-opensource-src-5.15.1.orig/sources/shiboken2/ApiExtractor/typedatabase.cpp
+++ pyside-setup-opensource-src-5.15.1/sources/shiboken2/ApiExtractor/typedatabase.cpp
@@ -899,7 +899,7 @@ void TypeEntry::formatDebug(QDebug &d) c
     if (m_name != cppName)
         d << "\", cppName=\"" << cppName << '"';
     d << ", type=" << m_type << ", codeGeneration=0x"
-        << Qt::hex << m_codeGeneration << Qt::dec
+        << hex << m_codeGeneration << dec
         << ", target=\"" << targetLangName() << '"';
     FORMAT_NONEMPTY_STRING("package", m_targetLangPackage)
     FORMAT_BOOL("stream", m_stream)
Index: pyside-setup-opensource-src-5.15.1/sources/shiboken2/ApiExtractor/typesystem.cpp
===================================================================
--- pyside-setup-opensource-src-5.15.1.orig/sources/shiboken2/ApiExtractor/typesystem.cpp
+++ pyside-setup-opensource-src-5.15.1/sources/shiboken2/ApiExtractor/typesystem.cpp
@@ -510,7 +510,7 @@ QDebug operator<<(QDebug d, const CodeSn
 
 void Modification::formatDebug(QDebug &d) const
 {
-    d << "modifiers=" << Qt::hex << Qt::showbase << modifiers << Qt::noshowbase << Qt::dec;
+    d << "modifiers=" << hex << showbase << modifiers << noshowbase << dec;
     if (removal)
       d << ", removal";
     if (!renamedToName.isEmpty())
Index: pyside-setup-opensource-src-5.15.1/examples/scriptableapplication/mainwindow.cpp
===================================================================
--- pyside-setup-opensource-src-5.15.1.orig/examples/scriptableapplication/mainwindow.cpp
+++ pyside-setup-opensource-src-5.15.1/examples/scriptableapplication/mainwindow.cpp
@@ -114,7 +114,7 @@ MainWindow::MainWindow()
 
 void MainWindow::slotRunScript()
 {
-    const QStringList script = m_scriptEdit->toPlainText().trimmed().split(QLatin1Char('\n'), Qt::SkipEmptyParts);
+    const QStringList script = m_scriptEdit->toPlainText().trimmed().split(QLatin1Char('\n'), QString::SkipEmptyParts);
     if (!script.isEmpty())
         runScript(script);
 }
